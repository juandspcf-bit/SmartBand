package com.misawabus.project.heartRate.Utils;

import java.util.Arrays;

public class UtilMethods {

    public static double[] reverse(double[] arr) {
        double[] inv = new double[arr.length];
        for (int i=0; i<inv.length; i++) {
            inv[i] = arr[arr.length-1-i];
        }
        return inv;
    }

    /**
     * This function returns the input array after reversing the order of the elements in it.
     * @param arr Array to be reversed
     * @return Complex[] Reversed array
     */

    public static int[] reverse(int[] arr) {
        int[] inv = new int[arr.length];
        for (int i=0; i<inv.length; i++) {
            inv[i] = arr[arr.length-1-i];
        }
        return inv;
    }

    public static double[] padSignal(double[] signal, String mode) {
        double[] newSignal;
        switch (mode) {
            case "reflect": {
                double[] revSig = reverse(signal);
                double[] newSig = {};
                newSig = concatenateArray(newSig, revSig);
                newSig = concatenateArray(newSig, signal);
                newSig = concatenateArray(newSig, revSig);
                newSignal = newSig;
                break;
            }
            case "constant": {
                double[] cons = new double[signal.length];
                Arrays.fill(cons, 0);
                double[] newSig = {};
                newSig = concatenateArray(newSig, cons);
                newSig = concatenateArray(newSig, signal);
                newSig = concatenateArray(newSig, cons);
                newSignal = newSig;
                break;
            }
            case "nearest": {
                double[] left = new double[signal.length];
                Arrays.fill(left, signal[0]);
                double[] right = new double[signal.length];
                Arrays.fill(right, signal[signal.length - 1]);

                double[] newSig = {};
                newSig = concatenateArray(newSig, left);
                newSig = concatenateArray(newSig, signal);
                newSig = concatenateArray(newSig, right);
                newSignal = newSig;
                break;
            }
            case "mirror": {
                double[] temp = splitByIndex(signal, 1, signal.length);
                temp = reverse(temp);
                double[] val = new double[]{temp[1]};
                double[] left = concatenateArray(val, temp);

                temp = splitByIndex(signal, 0, signal.length - 1);
                temp = reverse(temp);
                val = new double[]{temp[temp.length - 2]};
                double[] right = concatenateArray(temp, val);

                double[] newSig = {};
                newSig = concatenateArray(newSig, left);
                newSig = concatenateArray(newSig, signal);
                newSig = concatenateArray(newSig, right);
                newSignal = newSig;
                break;
            }
            case "wrap": {
                double[] newSig = {};
                newSig = concatenateArray(newSig, signal);
                newSig = concatenateArray(newSig, signal);
                newSig = concatenateArray(newSig, signal);
                newSignal = newSig;
                break;
            }
            default:
                throw new IllegalArgumentException("padSignalforConvolution modes can only be reflect, constant, " +
                        "nearest, mirror, or wrap");
        }
        return newSignal;
    }

    // Concatenate 2 arrays
    /**
     * This function returns the concatenation of the 2 input arrays.
     * @param arr1 Array to be added first
     * @param arr2 Array to be added second
     * @return double[] Concatenated array
     */
    public static double[] concatenateArray(double[] arr1, double[] arr2) {
        double[] out = new double[arr1.length + arr2.length];
        System.arraycopy(arr1, 0, out, 0, arr1.length);
        System.arraycopy(arr2, 0, out, arr1.length, arr2.length);
        return out;
    }

    /**
     * This function returns the concatenation of the 2 input arrays.
     * @param arr1 Array to be added first
     * @param arr2 Array to be added second
     * @return int[] Concatenated array
     */
    public static int[] concatenateArray(int[] arr1, int[] arr2) {
        int[] out = new int[arr1.length + arr2.length];
        System.arraycopy(arr1, 0, out, 0, arr1.length);
        System.arraycopy(arr2, 0, out, arr1.length, arr2.length);
        return out;
    }
    // Split an array by indices
    /**
     * This function returns the subset if an array depending on start and stop indices provided.
     * @param arr Array to be manipulated
     * @param start Start index for split
     * @param end Stop index for split
     * @return double[] Sub-array generated by splitting input array by start and end indices
     */
    public static double[] splitByIndex(double[] arr, int start, int end) {
        double[] out = new double[end-start];
        System.arraycopy(arr, start, out, 0, out.length);
        return out;
    }

    /**
     * This function returns the subset if an array depending on start and stop indices provided.
     * @param arr Array to be manipulated
     * @param start Start index for split
     * @param end Stop index for split
     * @return int[] Sub-array generated by splitting input array by start and end indices
     */
    public static int[] splitByIndex(int[] arr, int start, int end) {
        int[] out = new int[end-start];
        System.arraycopy(arr, start, out, 0, out.length);
        return out;
    }

}

